<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Bootstrapping peer...</title>
    <script>
        const SIGNALING_SERVER_URL = "{{ signaling_server_url }}";
        const TARGET_PEER_ID = "{{ target_peer_id }}";
        const HTTP_VERSION = "{{ http_version }}";
        const MY_ID = "gateway-" + Math.random().toString(36).substr(2, 9);

        let peerConnection;
        let ws;
        let isConnected = false;
        let connectionPromise = null;

        async function init() {
            if (!('serviceWorker' in navigator)) {
                document.body.innerText = "Service Workers not supported.";
                return;
            }

            // Listen for requests from the Service Worker
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data.type === 'FETCH_REQUEST') {
                    handleSWRequest(event.data, event.ports[0]);
                }
            });
            navigator.serviceWorker.startMessages();

            try {
                // Register the Service Worker
                const reg = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
                console.log('[Page] SW Registered:', reg.scope);

                // Start WebRTC Connection
                bootstrap().catch(err => {
                    console.error("WebRTC Bootstrap failed:", err);
                    document.body.innerText = "Connection Failed: " + err.message;
                });

                if (navigator.serviceWorker.controller) {
                    console.log('[Page] SW already controlling.');
                } else {
                    console.log('[Page] Waiting for SW control...');
                    navigator.serviceWorker.addEventListener('controllerchange', () => {
                        console.log('[Page] SW took control.');
                    });
                }
            } catch (err) {
                console.error('[Page] SW Registration Failed:', err);
                document.body.innerText = "Initialization Failed.";
            }
        }

        async function bootstrap() {
            if (isConnected) return;
            if (connectionPromise) return connectionPromise;

            connectionPromise = new Promise((resolve, reject) => {
                console.log("[Page] Connecting to Signaling Server:", SIGNALING_SERVER_URL);
                ws = new WebSocket(SIGNALING_SERVER_URL);

                ws.onopen = () => {
                    console.log("[Page] WS Open. Registering as:", MY_ID);
                    ws.send(JSON.stringify({ type: "register", id: MY_ID }));
                    startWebRTC(resolve, reject);
                };

                ws.onmessage = async (event) => {
                    const msg = JSON.parse(event.data);
                    handleSignalingMessage(msg);
                };

                ws.onerror = (e) => {
                    console.error("[Page] WS Error:", e);
                    reject(e);
                };
            });

            return connectionPromise;
        }

        async function startWebRTC(resolve, reject) {
            console.log("[Page] Starting WebRTC...");
            const config = {
                iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
            };

            peerConnection = new RTCPeerConnection(config);

            // Create a placeholder data channel to ensure the offer includes m=application (SCTP)
            peerConnection.createDataChannel("_init");

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // TODO Vanilla ICE for now
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log("[Page] Connection State:", peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    isConnected = true;
                    reloadContent();
                    resolve();
                }
            };

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            if (peerConnection.iceGatheringState !== 'complete') {
                await new Promise(resolve => {
                    const checkState = () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            peerConnection.removeEventListener('icegatheringstatechange', checkState);
                            resolve();
                        }
                    };
                    peerConnection.addEventListener('icegatheringstatechange', checkState);
                });
            }

            console.log("[Page] Sending Offer to:", TARGET_PEER_ID);
            ws.send(JSON.stringify({
                type: "offer",
                target: TARGET_PEER_ID,
                sender: MY_ID,
                sdp: peerConnection.localDescription.sdp
            }));
        }

        async function handleSignalingMessage(msg) {
            switch (msg.type) {
                case "answer":
                    await peerConnection.setRemoteDescription(new RTCSessionDescription({
                        type: "answer",
                        sdp: msg.sdp
                    }));
                    break;
                case "candidate":
                    if (msg.candidate) {
                        await peerConnection.addIceCandidate(msg.candidate);
                    }
                    break;
            }
        }

        const channelCache = new Map(); // serviceName -> { dc, queue, currentResponse: { ... } }

        async function handleSWRequest(reqData, port) {
            try {
                await bootstrap();

                const url = new URL(reqData.url);
                const hostname = url.hostname;
                const parts = hostname.split('.');
                let serviceName = parts.length > 0 ? parts[0] : "default";

                console.log(`[Page] Proxying ${reqData.method} ${url.pathname} to ${serviceName}`);

                let channelData = channelCache.get(serviceName);

                if (!channelData || channelData.dc.readyState !== 'open') {
                    // Create new DataChannel
                    const dcLabel = "req-" + Math.random().toString(36).substr(2, 5);
                    const dc = peerConnection.createDataChannel(dcLabel);

                    channelData = {
                        dc: dc,
                        queue: [],
                        currentResponse: null,
                        serviceName: serviceName,
                        isRequestInFlight: false
                    };
                    channelCache.set(serviceName, channelData);

                    setupChannelHandlers(channelData);

                    // Wait for open before processing
                    await new Promise((resolve, reject) => {
                        if (dc.readyState === 'open') resolve();
                        dc.addEventListener('open', resolve, { once: true });
                        dc.addEventListener('error', reject, { once: true });
                    });

                    // Send Preamble (only once per channel)
                    const serviceBytes = new TextEncoder().encode(serviceName);
                    const preamble = new Uint8Array(1 + serviceBytes.length);
                    preamble[0] = serviceBytes.length;
                    preamble.set(serviceBytes, 1);
                    dc.send(preamble);
                }

                // Enqueue Request
                channelData.queue.push({ reqData, port, url });
                processQueue(channelData);

            } catch (e) {
                console.error("Handle Request Error", e);
                port.postMessage({ type: 'ERROR', message: e.toString() });
            }
        }

        function setupChannelHandlers(channelData) {
            const dc = channelData.dc;

            dc.onmessage = (event) => {
                const chunk = new Uint8Array(event.data);
                const currentReq = channelData.queue[0];
                if (!currentReq) return;

                if (!channelData.currentResponse) {
                    channelData.currentResponse = {
                        buffer: [],
                        headersParsed: false,
                        contentLength: -1,
                        bytesReceived: 0
                    };
                }

                const respState = channelData.currentResponse;

                console.log("[Page] Received response chunk from DC:", chunk.length, "bytes", "headers parsed:", respState.headersParsed);
                if (respState.headersParsed) {
                    const len = chunk.length;
                    currentReq.port.postMessage({ type: 'RESPONSE_CHUNK', chunk }, [chunk.buffer]);
                    respState.bytesReceived += len;
                    checkResponseComplete(channelData);
                } else {
                    respState.buffer.push(...chunk);
                    const endpoint = findDoubleCRLF(respState.buffer);
                    if (endpoint !== -1) {
                        const headerBytes = new Uint8Array(respState.buffer.slice(0, endpoint));
                        const bodyBytes = new Uint8Array(respState.buffer.slice(endpoint + 4));
                        console.log("[Page] from DC, headerBytes", headerBytes.length, "bodyBytes", bodyBytes.length);

                        const headerStr = new TextDecoder().decode(headerBytes);
                        const { status, headers } = parseHeaders(headerStr);

                        // Check Content-Length for reuse
                        const cl = headers.get('content-length');
                        if (cl) {
                            respState.contentLength = parseInt(cl, 10);
                        } else {
                            // If no Content-Length, we can't reuse this channel reliably for next request
                            // unless it's chunked (not implemented) or 204/304.
                            // For safety, mark channel as 'closing' after this request.
                            channelData.closeAfterRequest = true;
                        }

                        // Send headers to SW
                        const headerList = [];
                        headers.forEach((v, k) => headerList.push([k, v]));
                        currentReq.port.postMessage({ type: 'RESPONSE_HEAD', status, headers: headerList });

                        respState.headersParsed = true;
                        if (bodyBytes.length > 0) {
                            const len = bodyBytes.length;
                            currentReq.port.postMessage({ type: 'RESPONSE_CHUNK', chunk: bodyBytes }, [bodyBytes.buffer]);
                            respState.bytesReceived += len;
                            console.log("[Page] Sent bodyBytes to SW. BytesReceived:", respState.bytesReceived, "bodyBytes:", len);
                        }
                        respState.buffer = []; // Clear buffer
                        checkResponseComplete(channelData);
                    }
                }
            };

            dc.onclose = () => {
                const currentReq = channelData.queue[0];
                if (currentReq) {
                    currentReq.port.postMessage({ type: 'RESPONSE_END' });
                    channelData.queue.shift();
                }
                channelCache.delete(channelData.serviceName);
                // If there are more requests in queue, they failed
                while (channelData.queue.length > 0) {
                    const req = channelData.queue.shift();
                    req.port.postMessage({ type: 'ERROR', message: "Channel closed unexpectedly" });
                }
            };

            dc.onerror = (e) => {
                console.error("DC Error", e);
                dc.close(); // Will trigger onclose
            };
        }

        function checkResponseComplete(channelData) {
            const respState = channelData.currentResponse;
            console.log("[Page] Checking if DC response is complete", respState.bytesReceived, respState.contentLength);
            if (respState.contentLength !== -1 && respState.bytesReceived >= respState.contentLength) {
                // Response Complete
                finishCurrentRequest(channelData);
            }
        }

        function finishCurrentRequest(channelData) {
            const currentReq = channelData.queue.shift();
            if (currentReq) {
                console.log("[Page] DC Response complete, sending RESPONSE_END");
                currentReq.port.postMessage({ type: 'RESPONSE_END' });
            }
            channelData.currentResponse = null;
            channelData.isRequestInFlight = false;

            if (channelData.closeAfterRequest) {
                channelData.dc.close();
            } else {
                processQueue(channelData);
            }
        }

        function processQueue(channelData) {
            if (channelData.queue.length === 0) return;
            // If we are already processing a request (currentResponse is set or waiting for headers), wait.
            if (channelData.currentResponse || channelData.isRequestInFlight) return;

            const req = channelData.queue[0];
            const dc = channelData.dc;

            try {
                channelData.isRequestInFlight = true;

                // 2. Send Request Line & Headers
                const headers = req.reqData.headers.map(h => `${h[0]}: ${h[1]}`);
                let reqStr = `${req.reqData.method} ${req.url.pathname + req.url.search} ${HTTP_VERSION}\r\n`;
                reqStr += headers.join('\r\n') + '\r\n\r\n';
                dc.send(new TextEncoder().encode(reqStr));

                // 3. Send Body
                if (req.reqData.body) {
                    dc.send(req.reqData.body);
                }
            } catch (e) {
                console.error("DC Send Error", e);
                channelData.isRequestInFlight = false;
                req.port.postMessage({ type: 'ERROR', message: e.toString() });
                channelData.queue.shift();
                processQueue(channelData);
            }
        }

        async function reloadContent() {
            console.log('[Page] Fetching actual content...');
            const controller = new AbortController();
            try {
                // Fetch the current URL. The Service Worker should intercept this
                // and proxy it through the now-established WebRTC connection.
                const response = await fetch(window.location.href, {
                    headers: { 'X-Peer-Proxy': 'true' },
                    signal: controller.signal
                });

                console.log('[Page] Fetched content with status:', response.status);

                if (!response.ok) {
                    throw new Error(`Fetch failed with status ${response.statusText} (${response.status})`);
                }

                const contentType = response.headers.get('content-type') || '';

                if (contentType.includes('text/html')) {
                    console.log('[Page] Got html content, updating current page');
                    const html = await response.text();
                    const parser = new DOMParser();
                    const newDoc = parser.parseFromString(html, 'text/html');

                    // 1. Merge <head> elements
                    document.title = newDoc.title;

                    // Copy all nodes from new head to existing head
                    Array.from(newDoc.head.childNodes).forEach(node => {
                        if (node.tagName === 'SCRIPT') {
                            const newScript = document.createElement('script');
                            Array.from(node.attributes).forEach(attr => {
                                newScript.setAttribute(attr.name, attr.value);
                            });
                            if (node.textContent) {
                                newScript.textContent = node.textContent;
                            }
                            document.head.appendChild(newScript);
                        } else {
                            document.head.appendChild(node.cloneNode(true));
                        }
                    });

                    // 2. Replace body content
                    document.body.innerHTML = newDoc.body.innerHTML;

                    // 3. Re-execute scripts from the new body
                    const scripts = Array.from(document.body.querySelectorAll('script'));
                    for (const oldScript of scripts) {
                        const newScript = document.createElement('script');
                        for (const attr of oldScript.attributes) {
                            newScript.setAttribute(attr.name, attr.value);
                        }
                        if (oldScript.textContent) {
                            newScript.textContent = oldScript.textContent;
                        }
                        oldScript.parentNode.replaceChild(newScript, oldScript);
                    }
                } else {
                    // Handle non-HTML content (images, videos, PDFs)
                    console.log('Got html content, updating in iframe');
                    const contentLength = response.headers.get('content-length');
                    const length = contentLength ? parseInt(contentLength, 10) : -1;
                    let url;

                    // If content is small (< 1MB), read it directly to avoid re-fetch overhead.
                    // This check is better than just checking for "chunked" (missing Content-Length)
                    // because it also protects against loading large files (e.g. 500MB videos) into memory
                    // even if they have a known Content-Length.
                    if (length !== -1 && length < 1024 * 1024) {
                        const blob = await response.blob();
                        url = URL.createObjectURL(blob);
                    } else {
                        // For large or unknown content, abort the initial fetch to save bandwidth
                        // and let the iframe trigger a new streaming request handled by the SW.
                        controller.abort();
                        url = window.location.href;
                    }

                    document.body.innerHTML = '';
                    const iframe = document.createElement('iframe');
                    iframe.src = url;
                    iframe.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; border:none;';
                    document.body.appendChild(iframe);
                }
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error('[Page] Content Load Failed:', err);
                document.body.innerHTML = `<h3>Connection Failed</h3><p>Failed to load content from peer.</p><p>${err.message}</p>`;
            }
        }

        function findDoubleCRLF(buffer) {
            for (let i = 0; i < buffer.length - 3; i++) {
                if (buffer[i] === 13 && buffer[i + 1] === 10 && buffer[i + 2] === 13 && buffer[i + 3] === 10) {
                    return i;
                }
            }
            return -1;
        }

        function parseHeaders(headerStr) {
            const lines = headerStr.split('\r\n');
            const statusLine = lines[0];
            const statusMatch = statusLine.match(/^HTTP\/[0-9.]+\s+(\d+)\s+(.+)$/);
            const status = statusMatch ? parseInt(statusMatch[1]) : 200;

            const headers = new Headers();
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line) continue;
                const colon = line.indexOf(':');
                if (colon > 0) {
                    headers.append(line.substring(0, colon).trim(), line.substring(colon + 1).trim());
                }
            }
            return { status, headers };
        }

        // Initialize on load
        window.onload = init;
    </script>
</head>

<body>
    Bootstrapping peer...
</body>

</html>